## 计算机基础

### ASCII unicode，utf8，utf16

ASCII => unicode，utf8，utf16

需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

比如，汉字严的 Unicode 是十六进制数 4E25，转换成二进制数足足有 15 位（100111000100101），也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。

这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。

UTF-16 比较好理解,就是任何字符对应的数字都用两个字节来保存。但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊.

于是又有个 UTF-8,这里的 8 非常容易误导人,8 不是指一个字节,难道一个字节表示一个字符?实际上不是.当用 UTF-8 时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过 3 个字节了.反正是根据字符对应的数字大小来确定.

于是 UTF-8 和 UTF-16 的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用 UTF-8 就比 UTF-16 节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16 就占优势了,可以节省很多空间

http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html

### base 64

base64 最早就是用来邮件传输协议中的，原因是邮件传输协议只支持 ascii 字符传递，因此如果要传输二进制文件，如：图片、视频是无法实现的。因此 base64 就可以用来将二进制文件内容编码为只包含 ascii 字符的内容，这样就可以传输了，但是这样一来，文件尺寸会比原来增加 1/3

6 个 bit 代表一个 ascii 字符

### PNG8 PNG24 PNG32

PNG8：PNG 8 中的 8，其实指的是 8bits，相当于用 2^8（2 的 8 次方）大小来存储一张图片的颜色种类，2^8 等于 256，也就是说 PNG 8 能存储 256 种颜色，一张图片如果颜色种类很少，将它设置成 PNG 8 得图片类型是非常适合的。

PNG24：PNG 24 中的 24，相当于 3 乘以 8 等于 24，就是用三个 8bits 分别去表示 R（红）、G（绿）、B（蓝）。R(0~255),G(0~255),B(0~255)，可以表达 256 乘以 256 乘以 256=16777216 种颜色的图片，这样 PNG 24 就能比 PNG 8 表示色彩更丰富的图片。但是所占用的空间相对就更大了。

PNG32：PNG 32 中的 32，相当于 PNG 24 加上 8bits 的透明颜色通道，就相当于 R（红）、G（绿）、B（蓝）、A（透明）。

### PNG 压缩

PNG 图片的压缩，分两个阶段：

- 预解析：
  png 图片用差分编码（Delta encoding）对图片进行预处理，处理每一个的像素点中每条通道的值，差分编码主要有几种：
- 压缩：
  压缩阶段会将预处理阶段得到的结果进行 Deflate 压缩，它由 Huffman 编码 和 LZ77 压缩构成。
  如前面所说，Deflate 压缩会标记图片所有的重复数据，并记录数据特征和结构，会得到一个压缩比最大的 png 图片 编码数据。

### 进程 线程

进程是 CPU 资源分配的最小单位
线程是 CPU 调度的最小单位

一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。
当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

### 网络七层协议

应用层
会话层
表示层
传输层
网络层
数据链路层
物理层

### TCP/IP 模型

应用层
传输层
网络层
网络接口

### TCP

TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能。

TCP 提供一种面向连接的、可靠的字节流服务
在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
TCP 使用校验和，确认和重传机制来保证可靠传输
TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制
注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。

### 三次握手

三次通信是理论上的最小值. 所以三次握手不是 TCP 本身的要求, 而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的。

一句话概括，TCP 连接握手，握的是啥？
通信双方数据原点的序列号！

“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。

SYN：同步序列编号（Synchronize Sequence Numbers）
ACK: 认字符 (Acknowledgement)

### upd

### https

### https 的性能损耗

http 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，https 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

### 中间人攻击

https://segmentfault.com/a/1190000013075736

问题的根源是因为“缺乏身份认证机制”，浏览器无法鉴别自己收到的密钥是不是真的来自于网站服务器。

### SSL/TLS

SSL/TLS 协议是为了解决这三大风险而设计的，希望达到：

（1） 所有信息都是加密传播，第三方无法窃听。

（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。

（3） 配备身份证书，防止身份被冒充。

### 各种类型 SSL 数字证书的区别

用于网站 HTTPS 化的 SSL 数字证书，当前主要分为 DV SSL、OV SSL、EV SSL 三种类型的证书。

### RSA

目前被破解的最长 RSA 密钥是 768 个二进制位。也就是说，长度超过 768 位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024 位的 RSA 密钥基本安全，2048 位的密钥极其安全。
互质关系
欧拉函数
模反元素

### 常见的加密

- 对称加密 ： 加密和解密数据使用同一个密钥。这种加密方式的优点是速度很快，常见对称加密的算法有 AES；
- 非对称加密： 加密和解密使用不同的密钥，叫公钥和私钥。数据用公钥加密后必须用私钥解密，数据用私钥加密后必须用公钥解密。一般来说私钥自己保留好，把公钥公开给别人，让别人拿自己的公钥加密数据后发给自己，这样只有自己才能解密。 这种加密方式的特点是速度慢，CPU 开销大，常见非对称加密算法有 RSA；
- Hash： hash 是把任意长度数据经过处理变成一个长度固定唯一的字符串，但任何人拿到这个字符串无法反向解密成原始数据（解开你就是密码学专家了），Hash 常用来验证数据的完整性。常见 Hash 算法有 MD5（已经不安全了）、SHA1、SHA256

### 怎样用通俗的语言解释 REST

URL 定位资源，用 HTTP 动词（GET,POST,DELETE,DETC）描述操作。

看 Url 就知道要什么
看 http method 就知道干什么
看 http status code 就知道结果如何

应该将 API 部署在专用域名之下：https://api.example.com
不用大写
用中杠-不用下杠\_；
参数列表要 encode；
URI 中不应该出现动词，动词应该使用 HTTP 方法表示，但是如果无法表示，也可使用动词，例如：search 没有对应的 HTTP 方法，可以在路径中使用 search，更加直观；
URI 中的名词表示资源集合，使用复数形式；
虽然/在 URI 中表达层级，但是避免为了追求 REST 导致层级过深，适当使用参数表示。

https://zhuanlan.zhihu.com/p/25647039

### 负载均衡的几种实现方式

- 实现方式
  这种方式，是通过将请求全部发送到前置机，由前置机通过算法 得出要分配给那台 应用服务器，然后响应给客户端，由客户端重定向到应用服务器的一种方式
- 反向代理
  这种方式，是通过在前置机，使用反向代理的方式，将请求分发到应用服务器，客户端无需再请求一次，实现方式通常有两种，一种是用交换机实现，还有一种是用 nginx 这一类的软件实现
- 数据链路返回
  这种方式，通过给应用服务器设置虚拟 IP，然后通过修改 mac 地址的方式，将请求分发出去，而应用服务器 收到请求后，可以直接响应给客户端，而不需要经过前置机。

1. 随机算法
   按权重设置随机概率
2. 轮询及加权轮询
   不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。
3. 最小连接数法
   最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前 积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。
4. IP 哈希算法
   通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。

### 不可变数据

很多对象和数组的操作都是有副作用的，一不小心就会导致错误。

可变的好处是节省内存或是利用可变性做一些事情，但是，在复杂的开发中它的副作用远比好处大的多。于是才有了浅 copy 和深 copy，就是为了解决这个问题。

Immutable.js 的实现原理：
Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

主要好处：没有副作用，节省内存，容易时间回溯

immer 原理：
immer 的做法就是维护一份 state 在内部，劫持所有操作，内部来判断是否有变化从而最终决定如何返回。

[更简单，更快速的创建不可变数据类型](https://zhangzhao.name/posts/immer-immutable/)

### diff 原理

[React 源码剖析系列 － 不可思议的 react diff](https://zhuanlan.zhihu.com/p/20346379)

传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。

React diff 策略
Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。

拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。

最开始经典的深度优先遍历 DFS 算法，其复杂度为 O(n^3)，存在高昂的 diff 成本

### React Fiber

同步更新过程的局限
破解 JavaScript 中同步操作时间过长的方法其实很简单——分片

https://zhuanlan.zhihu.com/p/26027085

### React Hooks

我们都知道 react 都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用 react，你会发现你的项目中实际上很多 react 组件冗长且难以复用。尤其是那些写成 class 的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。

- 多个状态不会产生嵌套
- 更容易将组件的 UI 与状态分离

而 Hooks 的出现本质是把这种面向生命周期编程变成了面向业务逻辑编程，你不用再去关心本不该关心的生命周期。

useEffect 生命周期

### 常见的置换算法

- LRU 缓存算法
  LRU 算法的思想是：如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）。

- FIFO
  如果一个数据是最先进入的，那么可以认为在将来它被访问的可能性很小。空间满的时候，最先进入的数据会被最早置换（淘汰）掉。

- LFU 算法
  ：如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。

## 浏览器相关知识

### 输入 url 发生了什么

### tcp udp

tcp/ip 的并发限制

### xmlHttpRequest

### http catch

### reflow reprint

渲染树的 reflow 或 repaint 的代价十分高昂，那么不得不采取一些优化的方式，浏览器对此有一些针对性的举措。一种策略便是延迟。浏览器会将一些变动放在一个队列中，当达到一定规模或者延迟的时间已到，那么会一次将这些变动反应到渲染树中。

```js
const div = document.getElementById('apple')
div.style.background = 'blue'

function sleep(sleepDuration) {
  var now = new Date().getTime()
  while (new Date().getTime() < now + sleepDuration) {
    /* do nothing */
  }
}
sleep(3000)
div.style.background = 'black'
```

### 浏览器内核

浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

- GUI 渲染线程
- JavaScript 引擎线程
- 定时触发器线程
- 事件触发线程
- 异步 http 请求线程

https://juejin.im/post/5c337ae06fb9a049bc4cd218

### 游览器缓存

浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。

|          | 获取资源形式 | 状态码            | 发送请求到服务器                 |
| -------- | ------------ | ----------------- | -------------------------------- |
| 强缓存   | 从缓存获取   | 200(from cache)   | 否，直接从缓存获取               |
| 协商缓存 | 从缓存获取   | 304(Not Modified) | 否，通过服务器来通知缓存是否可用 |

Cache-control > Expires > eTag > last-modified

当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：

- 本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送 http 请求到服务器；
- 协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个 http 请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回 304，让浏览器使用本地找到的那个资源；
- 缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回 200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回 404。

Cache-control 主要是为了解决用户的系统时间改到这个标识的时间之后，就永远不会命中这个强制缓存的问题。

eTag 主要为了解决 Last-Modified 无法解决的一些问题：

1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；

2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)；

3、某些服务器不能精确的得到文件的最后修改时间。

If-Modified-Since 和 If-None-Match

**延伸**
from disk cache(磁盘缓存)和 from memory cache(内存缓存) 的区别？
浏览器自己的一个缓存策略。
一般性 css 都是 disk cache
script 是 memory cache
当文件比较大时也会存在 disk cache

**Service Worker 缓存**

[一文读懂前端缓存](https://zhuanlan.zhihu.com/p/44789005)

### CDN

Content Delivery Network，即内容分发网络

- 用户访问 CDN 加速域名
- 本地 DNS 进行域名解析
- 本地 DNS 服务器将请求发送到网站 DNS 服务器，通过 CNAME 机制，请求指向 CDN 全球负载均衡集群
- 负载均衡集群通过智能解析，为用户分配相应速度最快的节点，本地 DNS 将节点 IP 返回给用户
- 用户对 CDN 节点进行请求

CDN 做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源

### DNS

Domain Name System 将域名和 IP 地址相互映射的一个分布式数据库
当浏览器访问一个域名的时候，需要解析一次 DNS，获得对应域名的 ip 地址。
浏览器缓存 => 系统缓存 => 路由器缓存 =>ISP(运营商)DNS 缓存 => 根域名服务器 => 顶级域名服务器 => 主域名服务器的顺序
逐步读取缓存，直到拿到 IP 地址

DNS 请求是走 UDP 的

DNS 的预解析

可以通过用 meta 信息来告知浏览器, 我这页面要做 DNS 预解析
`<meta http-equiv="x-dns-prefetch-control" content="on" />`

可以使用 link 标签来强制对 DNS 做预解析:
`<link rel="dns-prefetch" href="http://ke.qq.com/" />`

淘宝使用了上述方案。

### HttpDns 是什么

HTTPDNS 利用 HTTP 协议与 DNS 服务器交互，代替了传统的基于 UDP 协议的 DNS 交互，绕开了运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率。另外，由于 DNS 服务器端获取的是真实客户端 IP 而非 Local DNS 的 IP，能够精确定位客户端地理位置、运营商信息，从而有效改进调度精确性。

### Http

HTTP 方法:
GET,POST,PUT,PATCH,DELETE,OPTIONS
不太常用：CONNECT,TRACE,HEAD

HEAD：请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.
CONNECT： 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道
TRACE：被用于激发一个远程的，应用层的请求消息回路（译注：TRACE 方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路，）

PUT vs POST:
PUT 和 POST 方法的区别是,PUT 方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而 POST 方法是非幂等的。

PUT vs PATCH:
PUT 和 PATCH 都是更新资源，而 PATCH 用来对已知资源进行局部更新。

### http status code

- 1xx：临时回应，表示客户端请继续。
- 2xx：请求成功。
  - 200：请求成功。
  - 201：该请求已成功，并因此创建了一个新的资源。这通常是在 PUT 发送的响应。
  - 202：请求已经接收到，但还未响应，没有结果。
  - 204：表示请求成功，但响应报文不含实体的主体部分
  - 206：大文件断点续传
- 3xx: 表示请求的目标有变化，希望客户端进一步处理。
  - 301：永久性跳转
  - 302：临时性跳转
  - 303：对应当前请求的响应可以在另一个 URI 上被找到。
  - 304：跟客户端缓存没有更新。
- 4xx：客户端请求错误。
  - 400：请求报文存在语法错误
  - 401：表示发送的请求需要有通过 HTTP 认证的认证信息
  - 403：服务器已经理解请求，但是拒绝执行它。
  - 404：表示请求的页面不存在。
  - 408：请求超时。
  - 443：https
- 5xx：服务端请求错误。
  - 500：服务端错误。
  - 501：此请求方法不被服务器支持且无法被处理
  - 503：网关错误，服务端暂时性错误，可以一会再试。
  - 504：网关超时。

### keep-alive

在早期的 HTTP/1.0 中，每次 http 请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的 HTTP/1.0 中以及 HTTP/1.1 中，引入了重用连接的机制，就是在 http 请求头中加入 Connection: keep-alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定 HTTP/1.0 如果想要保持长连接，需要在请求头中加上 Connection: keep-alive。
keep-alive 的优点：

- 较少的 CPU 和内存的使用（由于同时打开的连接的减少了）
- 允许请求和应答的 HTTP 管线化
- 降低拥塞控制 （TCP 连接减少了）
- 减少了后续请求的延迟（无需再进行握手）
- 报告错误无需关闭 TCP 连

可以设置 timeout=5, max=100

### http2

[http/2 vs http/1.1 在线性能测试](https://http2.akamai.com/demo)
有个成语叫“事出有因”，每个事物都有其存在的意义（原因），而 HTTP/2 的诞生自然来自于 HTTP/1 的一些痛点。

https://github.com/amandakelake/blog/issues/35
https://github.com/creeperyang/blog/issues/23
https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn
https://imququ.com/post/header-compression-in-http2.html
https://imququ.com/post/http2-new-opportunities-and-challenges.html

- 二进制分帧层
- 请求与响应复用
- 数据流优先级

HPACK 头部压缩算法：
HPACK 头部压缩的基本原理就是使用索引表和 Huffman 编码

### keep-alive 与 多路复用 的区别

### http3

QUIC

### 端口号

1024< 端口 < 65535

### 输入一个 url

https://segmentfault.com/a/1190000019504744

### 哈夫曼编码

变长编码表是通过一种评估来源符号出现几率的方法得到的，出现几率高的字母使用较短的编码，反之出现几率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。

### gzip 原理

Gzip 的核心是 [Deflate](https://zh.wikipedia.org/wiki/DEFLATE) 算法 - 它是同时使用了 LZ77 算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。

### HSTS

HTTP Strict Transport Security, HTTP 严格传输安全)。HSTS 的作用是强制客户端与服务端建立安全的 HTTPS 连接，而非不安全的 HTTP 连接。如果一个站点启用了 HSTS 策略，那么客户端在第一次与该站点建立连接之后，在未来的一段时间内（由一个 HTTP 头部控制，这个头部为：Strict-Transport-Security），客户端与该站点的所有连接都会直接使用 HTTPS，即使客户端访问的是 HTTP，也会直接在客户端重定向到 HTTPS 连接。

### 慢查询

- 加索引
- 加缓存
- 加熔断

### redis

https://zhuanlan.zhihu.com/p/48080173

### 浏览器渲染原理

[图解浏览器的工作原理](https://mp.weixin.qq.com/s/X4yAFZBNLwaDUFYaR0Cn5g)

### rpc

rpc 是远端过程调用，其调用协议通常包含传输协议和序列化协议。

传输协议包含: 如著名的 [gRPC](grpc / grpc.io) 使用的 http2 协议，也有如 dubbo 一类的自定义报文的 tcp 协议

rpc 是远程过程调用，你可以这么理解，就是在另外一台服务器上有一段代码（函数），你可以通过网络远程调用它。用什么协议（http，tcp，udp…），传输什么数据格式（json，xml，二进制…）你都可以自己定义。

总结一下，RPC 要解决的两个问题：

1. 解决分布式系统中，服务之间的调用问题。

2. 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。

### JWT

JWT 的三个部分依次如下。

Header（头部）
Payload（负载）
Signature（签名）

客户端每次与服务器通信，都要带上这个 JWT。
