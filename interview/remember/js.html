<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 基础 | awesome-bookmarks</title>
    <meta name="description" content="个人收藏夹">
    <link rel="icon" href="/awesome-bookmarks/favicon.ico">
    
    <link rel="preload" href="/awesome-bookmarks/assets/css/0.styles.ec76dc0b.css" as="style"><link rel="preload" href="/awesome-bookmarks/assets/js/app.87218aed.js" as="script"><link rel="preload" href="/awesome-bookmarks/assets/js/74.093cb6a4.js" as="script"><link rel="prefetch" href="/awesome-bookmarks/assets/js/10.13a04629.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/11.dfa445b3.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/12.252e1ea1.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/13.202eea2f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/14.9a7f82ae.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/15.f30330ce.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/16.d8db4967.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/17.be2ef563.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/18.7f6a4069.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/19.e5c02e12.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/2.854dcf62.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/20.ed56267a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/21.542fe49d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/22.9aa62a89.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/23.62a907ea.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/24.6f88eaf3.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/25.884e6041.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/26.129b49e6.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/27.f099d417.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/28.24d3b4bf.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/29.27b8ad6a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/3.8b2a45ed.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/30.8463898b.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/31.6cb40446.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/32.54e1e517.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/33.851b4496.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/34.b68f93f4.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/35.18beea4a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/36.b349301f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/37.73c16f79.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/38.f7c8eefe.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/39.89522232.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/4.c4f29f89.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/40.9278113b.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/41.777c3c6d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/42.fb17c276.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/43.244e0c87.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/44.681de79b.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/45.f730c196.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/46.3375d240.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/47.a0544c28.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/48.40b5c1a1.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/49.15129fd2.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/5.7590f93c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/50.858fcf01.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/51.93b531cb.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/52.aea4550c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/53.07a0b368.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/54.4cfaeb40.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/55.276360c5.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/56.5615278a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/57.fafe2582.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/58.3a7aed53.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/59.5e8277d2.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/6.6174f641.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/60.ea7dff44.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/61.3277097f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/62.34744d93.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/63.b8a7d3da.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/64.efd176ee.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/65.c6aa2b44.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/66.1b9ba254.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/67.b4fc8277.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/68.7a4c27e8.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/69.211d809b.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/7.f8530e59.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/70.03138361.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/71.4c0527c5.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/72.57bf41d7.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/73.ab67e2c0.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/75.1e4daac6.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/76.79a45dda.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/77.0aa96205.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/78.d9ab8efc.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/79.9b9b3574.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/8.63235e5f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/80.8c11dd18.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/81.7409aad7.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/82.c7ddff18.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/83.e913e2f9.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/9.7bffc828.js">
    <link rel="stylesheet" href="/awesome-bookmarks/assets/css/0.styles.ec76dc0b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/awesome-bookmarks/" class="home-link router-link-active"><!----> <span class="site-name">awesome-bookmarks</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/awesome-bookmarks/" class="nav-link">首页</a></div><div class="nav-item"><a href="/awesome-bookmarks/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/awesome-bookmarks/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/awesome-bookmarks/diary/read.html" class="nav-link">最近阅读</a></div><div class="nav-item"><a href="/awesome-bookmarks/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/awesome-bookmarks/interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/awesome-bookmarks/job/" class="nav-link">内推</a></div><div class="nav-item"><a href="/awesome-bookmarks/blog/" class="nav-link">Blog</a></div> <a href="https://github.com/PanJiaChen/awesome-bookmarks" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/awesome-bookmarks/" class="nav-link">首页</a></div><div class="nav-item"><a href="/awesome-bookmarks/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/awesome-bookmarks/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/awesome-bookmarks/diary/read.html" class="nav-link">最近阅读</a></div><div class="nav-item"><a href="/awesome-bookmarks/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/awesome-bookmarks/interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/awesome-bookmarks/job/" class="nav-link">内推</a></div><div class="nav-item"><a href="/awesome-bookmarks/blog/" class="nav-link">Blog</a></div> <a href="https://github.com/PanJiaChen/awesome-bookmarks" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>面试</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/awesome-bookmarks/interview/" aria-current="page" class="sidebar-link">面试</a></li><li><a href="/awesome-bookmarks/interview/algorithms.html" class="sidebar-link">算法</a></li><li><a href="/awesome-bookmarks/interview/design-patterns.html" class="sidebar-link">设计模式</a></li><li><a href="/awesome-bookmarks/interview/js.html" class="sidebar-link">常规面试题</a></li><li><a href="/awesome-bookmarks/interview/network.html" class="sidebar-link">网络</a></li><li><a href="/awesome-bookmarks/interview/questions.html" class="sidebar-link">常规面试题</a></li><li><a href="/awesome-bookmarks/interview/react.html" class="sidebar-link">React</a></li><li><a href="/awesome-bookmarks/interview/vue.html" class="sidebar-link">Vue</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="js-基础"><a href="#js-基础" class="header-anchor">#</a> JS 基础</h2> <h3 id="mouseenter-与-mouseover-区别"><a href="#mouseenter-与-mouseover-区别" class="header-anchor">#</a> mouseenter 与 mouseover 区别</h3> <p>mouseenter 和 mouseleave 只有是 target element 的时候才会触发。 mouseover 和 mouseleave 会冒泡， 子元素也会触发。</p> <h3 id="e-target-与-e-currenttarget"><a href="#e-target-与-e-currenttarget" class="header-anchor">#</a> e.target 与 e.currentTarget</h3> <p>e.target 指向触发事件监听的对象。</p> <p>e.currentTarget 指向添加监听事件的对象。</p> <h3 id="isnan-vs-number-isnan"><a href="#isnan-vs-number-isnan" class="header-anchor">#</a> isNaN vs Number.isNaN</h3> <p>Number.isNaN() 方法确定传递的值是否为 NaN 和其类型是 Number。它是原始的全局 isNaN()的更强大的版本。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre></div><h3 id="number-issafeinteger"><a href="#number-issafeinteger" class="header-anchor">#</a> Number.isSafeInteger()</h3> <p>用来判断传入的参数值是否是一个“安全整数”（safe integer）。一个安全整数是一个符合下面条件的整数</p> <p>安全整数范围为 -(253 - 1)到 253 - 1 之间的整数</p> <h3 id="js-数值的最大最小值范围"><a href="#js-数值的最大最小值范围" class="header-anchor">#</a> js 数值的最大最小值范围</h3> <p>http://javascript.ruanyifeng.com/grammar/number.html</p> <p>BigInt</p> <h3 id="数组长度上限"><a href="#数组长度上限" class="header-anchor">#</a> 数组长度上限</h3> <p>Math.pow(2,32)-1</p> <h3 id="tostring-valueof"><a href="#tostring-valueof" class="header-anchor">#</a> toString valueOf</h3> <h3 id="addeventlistener"><a href="#addeventlistener" class="header-anchor">#</a> addEventListener</h3> <ul><li>内存泄漏问题，只有保持静态函数引用才能被 <code>removeEventListener</code> 移除。</li> <li>passive: 提升页面滑动的流畅度</li> <li>useCapture: 事件捕获阶段触发 handler</li> <li>once: 只触发一次</li></ul> <h3 id="哪些事件不会事件冒泡"><a href="#哪些事件不会事件冒泡" class="header-anchor">#</a> 哪些事件不会事件冒泡</h3> <ul><li>UI 事件
<ul><li>load</li> <li>unload</li> <li>scroll</li> <li>resize</li></ul></li> <li>焦点事件
<ul><li>blur</li> <li>focus</li></ul></li> <li>鼠标事件
<ul><li>mouseleave</li> <li>mouseenter</li></ul></li></ul> <h3 id="dispatchevent"><a href="#dispatchevent" class="header-anchor">#</a> dispatchEvent</h3> <p>通过 dispatchEvent <code>new CustomEvent('myEvent', {detail:123});</code> 来触发自定义事件</p> <p>注意 new Event('build') vs new CustomEvent('build')</p> <h3 id="jsonp-原理"><a href="#jsonp-原理" class="header-anchor">#</a> JSONP 原理</h3> <ul><li>在使用 JSONP 的时候必须要保证使用的 JSONP 服务必须是安全可信的。会有安全问题</li> <li>JSONP 在调用失败的时候不会返回各种 HTTP 状态码</li> <li>JSONP 只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求。</li></ul> <h3 id="_7-中类型"><a href="#_7-中类型" class="header-anchor">#</a> 7 中类型</h3> <p>Number 、Null、Undefined、String、 Boolean 、Object 、Symbol</p> <h3 id="原生对象"><a href="#原生对象" class="header-anchor">#</a> 原生对象</h3> <p><img src="https://wpimg.wallstcn.com/5c2fdb22-51ca-4206-918d-042ad5dbee1f.png" alt></p> <h3 id="null-vs-undefined"><a href="#null-vs-undefined" class="header-anchor">#</a> null vs undefined</h3> <ul><li><p>null 表示&quot;没有对象&quot;，即该处不应该有值
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。</p></li> <li><p>undefined 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。
（1）变量被声明了，但没有赋值时，就等于 undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
（3）对象没有赋值的属性，该属性的值为 undefined。
（4）函数没有返回值时，默认返回 undefined。</p></li></ul> <h3 id="为什么用-void-0-代替-undefined"><a href="#为什么用-void-0-代替-undefined" class="header-anchor">#</a> 为什么用 void 0 代替 undefined</h3> <p>答案很简单，undefined 并不是保留词（reserved word），它只是全局对象的一个属性，在低版本 IE 中能被重写。
undefined 在 ES5 中已经是全局对象的一个只读（read-only）属性了，它不能被重写。但是在局部作用域中，还是可以被重写的。
那么，ES5 大环境下，void 0 就没有用武之地了吗？答案是否定的，用 void 0 代替 undefined 能节省不少字节的大小，事实上，不少 JavaScript 压缩工具在压缩过程中，正是将 undefined 用 void 0 代替掉了。不少基础库如 underscore、vue 都是用 void 0 的</p> <h3 id="charcodeat-vs-codepointat"><a href="#charcodeat-vs-codepointat" class="header-anchor">#</a> charCodeAt vs codePointAt</h3> <p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。ES6 提供了 codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">'𠮷a'</span>
s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 134071</span>
s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 57271</span>

s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 97</span>
</code></pre></div><h3 id="精度问题"><a href="#精度问题" class="header-anchor">#</a> 精度问题</h3> <p>es6 解决方案：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span>
</code></pre></div><p>IEEE 754
使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有 float 32 位单精度）。计算机组成原理中有过详细介绍，如果你不记得也没关系。</p> <p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。</p> <p>64 位比特又可分为三个部分：</p> <p>符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数
指数位 E：中间的 11 位存储指数（exponent），用来表示次方数
尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</p> <h3 id="object-create-vs-new-function"><a href="#object-create-vs-new-function" class="header-anchor">#</a> Object.create vs new Function</h3> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function-variable function">create</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 隐式构造函数</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回一个new</span>
<span class="token punctuation">}</span>
</code></pre></div><p>延伸： Object.create(null) vs {}</p> <p>https://panjiachen.github.io/awesome-bookmarks/blog/js.html#object-create-null-vs</p> <h3 id="继承的多种方式"><a href="#继承的多种方式" class="header-anchor">#</a> 继承的多种方式</h3> <ul><li>原型链继承</li> <li>借用构造函数(经典继承)</li> <li>组合继承</li> <li>原型式继承</li> <li>寄生式继承</li> <li>寄生组合式继承</li></ul> <p>https://github.com/mqyqingfeng/Blog/issues/16</p> <h3 id="普通函数-构造函数-箭头函数"><a href="#普通函数-构造函数-箭头函数" class="header-anchor">#</a> 普通函数 构造函数 箭头函数</h3> <p>构造函数：</p> <ol><li>构造函数使用 new 关键字调用；普通函数不用 new 关键字调用；</li> <li>构造函数内部可以使用 this 关键字；普通函数内部不建议使用 this，因为这时候 this 指向的是 window 全局对象，这样无意间就会为 window 添加了一些全局变量或函数</li> <li>构造函数默认不用 return 返回值；普通函数一般都有 return 返回值</li> <li>构造函数首字母一般大写</li></ol> <p>箭头函数：</p> <ol><li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</li> <li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</li> <li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li> <li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
https://segmentfault.com/a/1190000015162781</li></ol> <p>箭头函数不适用场景：</p> <ul><li>定义字面量方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> calculator <span class="token operator">=</span> <span class="token punctuation">{</span>
  array<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sum</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> result <span class="token operator">+</span> item<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
<span class="token comment">// Throws &quot;TypeError: Cannot read property 'reduce' of undefined&quot;</span>
calculator<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><p>定义原型方法
如上同理</p></li> <li><p>是需要动态 this 的时候，也不应使用箭头函数。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myButton'</span><span class="token punctuation">)</span>
button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> button<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'Clicked button'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面代码运行时，点击按钮会报错，因为 button 的监听函数是一个箭头函数，导致里面的 this 就是全局对象。如果改成普通函数，this 就会动态指向被点击的按钮对象。</p> <h3 id="类型判断"><a href="#类型判断" class="header-anchor">#</a> 类型判断</h3> <h3 id="字符串有最大长度吗"><a href="#字符串有最大长度吗" class="header-anchor">#</a> 字符串有最大长度吗</h3> <p>JS 字符串的长度受到下标限制。理论最大长度是 2^53-1（即 js 中可表达的最大安全整数）。</p> <h3 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h3> <h4 id="promise-resolve-一定是走-success-的么？"><a href="#promise-resolve-一定是走-success-的么？" class="header-anchor">#</a> promise.resolve 一定是走 success 的么？</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error <span class="token operator">+</span> <span class="token string">'---error'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><h4 id="catch-的两种写法"><a href="#catch-的两种写法" class="header-anchor">#</a> catch 的两种写法</h4> <p>Promise.prototype.catch 方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p> <h4 id="reject"><a href="#reject" class="header-anchor">#</a> reject</h4> <p>reject 方法的作用，等同于抛出错误。
如果 Promise 状态已经变成 resolved，再抛出错误是无效的。
因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span> <span class="token comment">// 但还是会执行</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// ok</span>
</code></pre></div><h4 id="allsettled-any"><a href="#allsettled-any" class="header-anchor">#</a> allSettled,any</h4> <h4 id="generator"><a href="#generator" class="header-anchor">#</a> generator</h4> <p>实现一个状态机</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">clock</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tick!'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tock!'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="协程与子例程的差异"><a href="#协程与子例程的差异" class="header-anchor">#</a> 协程与子例程的差异</h4> <p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。
协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p> <p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p> <p>http://es6.ruanyifeng.com/#docs/generator#Generator-%E4%B8%8E%E5%8D%8F%E7%A8%8B</p> <h3 id="宏观任务-微观任务"><a href="#宏观任务-微观任务" class="header-anchor">#</a> 宏观任务 微观任务</h3> <p>由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p> <p>macro-task 包括：script(整体代码,主进程), setTimeout, setInterval, setImmediate, I/O, UI rendering, requestAnimationFrame。
micro-task 包括：process.nextTick, Promise 回调, Object.observe(已废弃), MutationObserver(DOM 变化监听器)</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> begin <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> begin <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
</code></pre></div><p>process.nextTick &gt; Promise.then &gt; MutationObserver</p> <p>JS stack =&gt; Microtasks =&gt; Tasks
Tasks</p> <p>延伸： vue 的 nextTick 是什么</p> <p>https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
https://juejin.im/post/59e85eebf265da430d571f89
https://juejin.im/post/5b35cdfa51882574c020d685</p> <h3 id="settimeout-setinterval-setimmediate-process-nexttick"><a href="#settimeout-setinterval-setimmediate-process-nexttick" class="header-anchor">#</a> setTimeout setInterval setImmediate process.nextTick</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// test.js</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html</p> <p>注意</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>他们两者的执行顺序是不确定的
https://imweb.io/topic/5b148768d4c96b9b1b4c4ea1</p> <h3 id="settimeout-setinterval"><a href="#settimeout-setinterval" class="header-anchor">#</a> setTimeout setInterval</h3> <p>对于 setInterval(fn,ms)来说，我们已经知道不是每过 ms 秒会执行一次 fn，而是每过 ms 秒，会有 fn 进入 Event Queue。
一旦 setInterval 的回调函数 fn 执行时间超过了延迟时间 ms，那么就完全看不出来有时间间隔了</p> <h3 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> event loop</h3> <p>timers
I/O callbacks
idle, prepare
poll
check
close callbacks</p> <h3 id="浏览器和-node-事件循环的区别"><a href="#浏览器和-node-事件循环的区别" class="header-anchor">#</a> 浏览器和 Node 事件循环的区别</h3> <p>ibev 只能在 Unix 环境下运行。Windows 平台上与 kqueue(FreeBSD)或者(e)poll(Linux)等内核事件通知相应的机制是 IOCP。
libuv 提供了一个跨平台的抽象，由平台决定使用 libev 或 IOCP。</p> <p>们所看到的 node.js 单线程只是一个 js 主线程，本质上的异步操作还是由线程池完成的，node 将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，并没有进行真正的 I/O 操作，从而实现异步非阻塞 I/O，这便是 node 单线程和事件驱动的精髓之处了。</p> <h3 id="promise-原理"><a href="#promise-原理" class="header-anchor">#</a> promise 原理</h3> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async await</h3> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h2> <h3 id="tree-shaking"><a href="#tree-shaking" class="header-anchor">#</a> tree-shaking</h3> <h3 id="typeof"><a href="#typeof" class="header-anchor">#</a> typeOf</h3> <p><a href="https://github.com/lifesinger/blog/issues/175" target="_blank" rel="noopener noreferrer">玉伯的分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>Object.prototype.toString.call(obj)</code></p> <p>instanceof 在 iframe 中会有问题。因为多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">''</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">//false</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">//true</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment">//true</span>
</code></pre></div><p>Object.prototype.toString 的原理是：
在 toString 方法被调用时,会执行下面的操作步骤:
获取 this 对象的[[Class]]属性的值，es6 中已调整为 <code>NativeBrand</code>
由于是获取 this 的属性，所以必须要使用 call 或者 apply。</p> <h3 id="object-defineproperty"><a href="#object-defineproperty" class="header-anchor">#</a> Object.defineProperty</h3> <p>value, writable,enumerable,configurable</p> <h3 id="proxy"><a href="#proxy" class="header-anchor">#</a> proxy</h3> <p>双向绑定一般有如下几种方法：</p> <ul><li>发布-订阅 KnockoutJS</li> <li>脏检查 Angular</li> <li>Object.defineProperty Vue2.x</li> <li>proxy Vue3.x</li></ul> <p>Proxy 是 Object.defineProperty 的全方位加强版，可以直接监听对象而非属性，Proxy 可以直接监听数组的变化。
<a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf" target="_blank" rel="noopener noreferrer">实现双向绑定 Proxy 比 defineProperty 优劣如何<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="尾调用"><a href="#尾调用" class="header-anchor">#</a> 尾调用</h3> <h3 id="new-做了些什么"><a href="#new-做了些什么" class="header-anchor">#</a> new 做了些什么</h3> <p>四大步骤：</p> <p>1、创建一个空对象，并且 this 变量引用该对象，// lat target = {};</p> <p>2、继承了函数的原型。// target.proto = func.prototype;</p> <p>3、属性和方法被加入到 this 引用的对象中。并执行了该函数 func// func.call(target);</p> <p>4、新创建的对象由 this 所引用，并且最后隐式的返回 this 。// 如果 func.call(target)返回的 res 是个对象或者 function 就返回它</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	lat target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	target<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> func<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
	<span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> target<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="mvc-mvp-mvvm"><a href="#mvc-mvp-mvvm" class="header-anchor">#</a> MVC MVP MVVM</h3> <ul><li>MVC: Controller 作为 View 层和 Model 层之间的连接点，连接 View -&gt; Model 之间的通信，Model 层的数据更新后会通知 View 层的视图更新并反馈给用户。View 和 Model 之间的强耦合度会加大调试时的难度。</li> <li>MVP: Presenter 承接起了 View 和 Model 之间的双向通信，View 与 Model 不发生联系，降低了耦合度且方便单元测试。</li> <li>MVVM: ViewModel 中构建了一组状态数据，作为 View 状态的抽象，通过双向数据绑定使 ViewModel 中的状态数据与 View 的显示状态保持一致，这样 View 的显示状态变化会自动更新 ViewModel 的状态数据，ViewModel 状态数据的变化也会自动同步 View 的显示状态。</li></ul> <p>https://www.zhihu.com/question/20148405</p> <h3 id="前端模块"><a href="#前端模块" class="header-anchor">#</a> 前端模块</h3> <h3 id="fetch-优缺点"><a href="#fetch-优缺点" class="header-anchor">#</a> fetch 优缺点</h3> <ul><li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里
更好更方便的写法</li> <li>更加底层，提供的 API 丰富（request, response）</li> <li>脱离了 XHR，是 ES 规范里新的实现方式</li> <li>fetchtch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理</li> <li>fetch 默认不会带 cookie，需要添加配置项</li> <li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li> <li>fetch 没有办法原生监测请求的进度，而 XHR 可以。</li></ul> <h3 id="xmlhttprequest"><a href="#xmlhttprequest" class="header-anchor">#</a> XMLHttpRequest</h3> <p><code>xhrReq.open(method, url, async, user, password)</code></p> <p><code>readyState</code>:</p> <ul><li>0 UNSENT 代理被创建，但尚未调用 open() 方法。</li> <li>1 OPENED open() 方法已经被调用。</li> <li>2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。</li> <li>3 LOADING 下载中； responseText 属性已经包含部分数据。</li> <li>4 DONE 下载操作已完成。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="fragment"><a href="#fragment" class="header-anchor">#</a> fragment</h3> <p><code>let fragment = document.createDocumentFragment();</code></p> <h3 id="深拷贝"><a href="#深拷贝" class="header-anchor">#</a> 深拷贝</h3> <h3 id="尾调用-2"><a href="#尾调用-2" class="header-anchor">#</a> 尾调用</h3> <h3 id="weakmap-作用"><a href="#weakmap-作用" class="header-anchor">#</a> WeakMap 作用</h3> <h3 id="for-in，object-keys-object-getownpropertynames-的区别"><a href="#for-in，object-keys-object-getownpropertynames-的区别" class="header-anchor">#</a> for...in，Object.keys Object.getOwnPropertyNames 的区别</h3> <p>Object.getOwnPropertyNames(a) returns all own properties of the object a.
Object.keys(a) returns all enumerable own properties.
It means that if you define your object properties without making some of them enumerable: false these two methods will give you the same result.</p> <p>getOwnPropertyNames 可以用来判断是否是空对象。</p> <h3 id="css-in-js"><a href="#css-in-js" class="header-anchor">#</a> css in js</h3> <h3 id="css-module"><a href="#css-module" class="header-anchor">#</a> css module</h3> <h3 id="cookie-session"><a href="#cookie-session" class="header-anchor">#</a> cookie session</h3> <p>cookie 不设置时间就是当浏览器全部关闭时失效
而 sessionStorage 是当 tab 关闭时就失效，tab 之间不共享。
有特殊例子：如通过 a 页面链接(或者用了 window.open)点开了 b 页面，它们之间是共享的。</p> <h3 id="es6-模块与-commonjs-模块的差异"><a href="#es6-模块与-commonjs-模块的差异" class="header-anchor">#</a> ES6 模块与 CommonJS 模块的差异</h3> <ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li> <li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li> <li>CommonJS 模块的顶层 this 指向当前模块。ES6 模块之中，顶层的 this 指向 undefined，这是两者的一个重大差异。</li></ul> <p>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p> <h3 id="循环依赖加载问题"><a href="#循环依赖加载问题" class="header-anchor">#</a> 循环依赖加载问题</h3> <p>CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span>
  exports<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  loaded<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的 id 属性是模块名，exports 属性是模块输出的各个接口，loaded 属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p> <p>以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p> <p>es6</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//foo.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo is running'</span><span class="token punctuation">)</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./bar'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar = %j'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar = %j after 500 ms'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo is finished'</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//bar.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar is running'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>bar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar is finished'</span><span class="token punctuation">)</span>
</code></pre></div><p>结果：
bar is running
bar is finished
foo is running
bar = false
foo is finished
bar = true after 500 ms</p> <p>https://zhuanlan.zhihu.com/p/33049803</p> <h3 id="amd-cmd-umd"><a href="#amd-cmd-umd" class="header-anchor">#</a> AMD CMD UMD</h3> <ul><li>AMD 推崇依赖前置、提前执行</li> <li>CMD 推崇依赖就近、延迟执行</li> <li>UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式。
在判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。</li></ul> <h3 id="module-exports-和-exports-区别"><a href="#module-exports-和-exports-区别" class="header-anchor">#</a> module.exports 和 exports 区别</h3> <p>exports 就是 module.exports 的别名，是用来简化书写的</p> <h3 id="async-与-generator-区别"><a href="#async-与-generator-区别" class="header-anchor">#</a> async 与 Generator 区别</h3> <ol><li><p>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。
也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p></li> <li><p>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p></li> <li><p>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，
而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p></li></ol> <h3 id="stopimmediatepropagation-vs-stoppropagation"><a href="#stopimmediatepropagation-vs-stoppropagation" class="header-anchor">#</a> stopImmediatePropagation vs stopPropagation</h3> <p>stopPropagation()方法阻止事件对象移到到另一个节点上，但是允许当前节点的其他事件监听函数执行，而 stopImmediatePropagation()方法不仅阻止事件从当前节点移动到另一个节点上，它还不允许当前节点的其他事件监听函数执行。</p> <h3 id="serviceworker"><a href="#serviceworker" class="header-anchor">#</a> serviceWorker</h3> <h3 id="重绘（repaint）和回流（reflow）"><a href="#重绘（repaint）和回流（reflow）" class="header-anchor">#</a> 重绘（Repaint）和回流（Reflow）</h3> <h2 id="webpack-2"><a href="#webpack-2" class="header-anchor">#</a> webpack</h2> <h2 id="babel"><a href="#babel" class="header-anchor">#</a> babel</h2> <p>https://juejin.im/post/5d0373a95188251e1b5ebb6c</p> <h3 id="performance"><a href="#performance" class="header-anchor">#</a> performance</h3> <p>js：压缩，拆分，tree-shaking，按需，gzip
css：压缩，按需，gzip
img：cdn，http cache
http：gzip dns-prefetch perload prefetch
svg: 压缩合并</p> <h3 id="document-的-load-事件和-domcontentloaded-事件之间的区别"><a href="#document-的-load-事件和-domcontentloaded-事件之间的区别" class="header-anchor">#</a> document 的 load 事件和 DOMContentLoaded 事件之间的区别</h3> <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。
load 事件仅在 DOM 和所有相关资源全部完成加载后才会触发。</p> <h3 id="sort-原理"><a href="#sort-原理" class="header-anchor">#</a> sort 原理</h3> <p>chrome 当数组长度小于等于 10 的时候，采用插入排序，大于 10 的时候，采用快排。</p> <p>火狐：用归并排序的
ie：快速排序</p> <p>es10 之后 改用 Timsort 算法 - TimSort 是 Python 中 list.sort 的默认实现</p> <p>Timsort 是结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法，它在现实中有很好的效率</p> <h3 id="前端路由"><a href="#前端路由" class="header-anchor">#</a> 前端路由</h3> <p>hash: 基于 hashchange
history: 基于 History API 的方法和属性。<code>history.pushState</code>、<code>history.replaceState</code>、<code>popstate</code></p> <h3 id="const-运算题"><a href="#const-运算题" class="header-anchor">#</a> const 运算题</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token string">'ok'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
</code></pre></div><h3 id="强引用-运算题"><a href="#强引用-运算题" class="header-anchor">#</a> 强引用 运算题</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

key <span class="token operator">=</span> <span class="token keyword">null</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
</code></pre></div><h3 id="set-weakset"><a href="#set-weakset" class="header-anchor">#</a> set weakSet</h3> <p>数组去重：<code>[...new Set(array)]</code>
字符串去重：<code>[...new Set('ababbc')].join('')</code></p> <p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p> <ul><li>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</li> <li>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li></ul> <h3 id="map-weakmap"><a href="#map-weakmap" class="header-anchor">#</a> map weakMap</h3> <p>map 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p> <p>WeakMap 与 Map 的区别有两点。</p> <ul><li>首先，WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。</li> <li>其次，WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul> <p>应用</p> <ol><li>在 DOM 对象上保存相关数据</li> <li>数据缓存</li> <li>私有属性</li></ol> <h3 id="_0-0"><a href="#_0-0" class="header-anchor">#</a> -0 +0</h3> <p>数字需要被编码才能进行数字化存储.举个例子,假如我们要将一个整数编码为 4 位的二进制数,使用原码(sign-and-magnitude)方法,则最高位是符号位(0 代表正,1 代表负),剩下的三位表示大小(具体的值).因此,−2 和+2 会编码成为下面这样:</p> <p>二进制的 1010 表示十进制的 −2
二进制的 0010 表示十进制的+2</p> <p>这就意味着将会有两个零:1000(-0)和 0000(0).</p> <p>但大部分时候使用的时候 js 默认都会先执行<code>toString</code>，所以两者在使用时没有什么区别。</p> <p>区分：
判断一个零是正还是负的标准解法是用它除 1,然后看计算的结果是-Infinity 还是+Infinity:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isNegativeZero</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token number">1</span> <span class="token operator">/</span> x <span class="token operator">&lt;</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="柯里化函数"><a href="#柯里化函数" class="header-anchor">#</a> 柯里化函数</h3> <p>应用场景：</p> <ol><li>延迟计算</li> <li>动态创建函数 - 浏览器兼容性</li></ol> <p>https://github.com/yygmind/blog/issues/37</p> <h3 id="input-如何处理中文输入法"><a href="#input-如何处理中文输入法" class="header-anchor">#</a> input 如何处理中文输入法</h3> <p><code>compositionend</code> <code>compositionupdate</code> <code>compositionend</code></p> <h3 id="模拟实现一个-promise-finally"><a href="#模拟实现一个-promise-finally" class="header-anchor">#</a> 模拟实现一个 Promise.finally</h3> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">finally</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>constructor
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
      <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token parameter">reason</span> <span class="token operator">=&gt;</span>
        <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> reason
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="url-长度限制"><a href="#url-长度限制" class="header-anchor">#</a> url 长度限制</h3> <p>不同浏览器对 url 长度有不同的限制，IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte。
所以 get 请求参数或者 jsonp 都会有所限制。</p> <h3 id="图片懒加载"><a href="#图片懒加载" class="header-anchor">#</a> 图片懒加载</h3> <p>最新可使用 <code>IntersectionObserver</code> api</p> <p>https://zhuanlan.zhihu.com/p/25455672</p> <h3 id="valueof-与-tostring-区别"><a href="#valueof-与-tostring-区别" class="header-anchor">#</a> valueOf 与 toString 区别</h3> <p>valueOf()：返回最适合该对象类型的原始值；
toString(): 将该对象的原始值以字符串形式返回。
这两个方法一般是交由 JS 去隐式调用，以满足不同的运算情况。
在数值运算里，会优先调用 valueOf()，
如 a + b；在字符串运算里，会优先调用 toString()，如 alert(c)。
中</p> <h3 id="javascript-装饰器的实现原理"><a href="#javascript-装饰器的实现原理" class="header-anchor">#</a> Javascript 装饰器的实现原理</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 装饰类</span>
@decorator
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 等同于</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token constant">A</span> <span class="token operator">=</span> <span class="token function">decorator</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token constant">A</span>
</code></pre></div><p>方法基于 <code>defineProperty</code></p> <h3 id="requestanimationframe"><a href="#requestanimationframe" class="header-anchor">#</a> requestAnimationFrame</h3> <p>作用就是让浏览器流畅的执行动画效果</p> <h3 id="前端开发中如何在-js-文件中检测用户浏览器是否打开了调试面板"><a href="#前端开发中如何在-js-文件中检测用户浏览器是否打开了调试面板" class="header-anchor">#</a> 前端开发中如何在 JS 文件中检测用户浏览器是否打开了调试面板</h3> <p>https://www.zhihu.com/question/24188524</p> <h3 id="object-freeze-vs-object-seal-vs-object-preventextensions"><a href="#object-freeze-vs-object-seal-vs-object-preventextensions" class="header-anchor">#</a> Object.freeze vs Object.seal vs Object.preventExtensions</h3> <p>https://github.com/piecioshka/test-freeze-vs-seal-vs-preventExtensions
https://stackoverflow.com/questions/21402108/difference-between-freeze-and-seal</p> <h3 id="内存泄漏"><a href="#内存泄漏" class="header-anchor">#</a> 内存泄漏</h3> <ul><li>意外的全局变量</li> <li>被遗忘的计时器或回调函数</li> <li>闭包</li> <li>脱离 DOM 的引用</li></ul> <h3 id="es5-和-es6-及继承机制"><a href="#es5-和-es6-及继承机制" class="header-anchor">#</a> ES5 和 ES6 及继承机制</h3> <p>ES5 的继承机制简单来说就是：实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）</p> <p>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/PanJiaChen/awesome-bookmarks/edit/master/docs/interview/remember/js.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">11/14/2019, 3:15:12 AM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/awesome-bookmarks/assets/js/app.87218aed.js" defer></script><script src="/awesome-bookmarks/assets/js/74.093cb6a4.js" defer></script>
  </body>
</html>
